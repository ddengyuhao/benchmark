%!TEX root = ../main.tex
\section{Benchmark Design} 
In this section, we first introduce the design goals of \sys benchmark for table discovery tasks, and then present how to generate the \sys benchmark consisting of datasets, queries and ground truth.

\subsection{Design Goals}
We design the table discovery benchmark by the 
benchmark design criteria proposed by Jim Gray.

\noindent\textbf{Relevance.}
The benchmark covers a wide range of table discovery characteristics. First, in terms of the data lake, we incorporate 4 lakes with size ranging from 10GB to 1TB, and with column number ranging from \cc{1 million} to 10 million. Second, in terms of the queries, with the help of much human efforts, we create and label more than 10 thousand table queries that cover various query characteristics, including column semantic, column overlapping, column size, etc.



\noindent\textbf{Scalability.} The benchmark involves much larger data lakes than existing data lakes for table discovery. The data lake size should be considered from two aspects. One is the normal total storage size that is highly related  to the average table size  and the number of tables. The other is the number of total columns because almost all table discovery algorithms build index and search over a large number of columns.  \sys involves up to 1 TB data lake and 10 million columns, which is sufficient enough to evaluate the scalability.




\noindent\textbf{Simplicity.} The benchmark designs easy-to-use APIs to support table discovery in data lakes. Users can simply leverage few lines of codes to query our benchmark datasets using different algorithms and compare with them.
\cc{seems limited}









\subsection{Benchmark Overview}


\noindent\textbf{Datasets}
We collect three datasets from OpenData~\cite{OpenData}, WebTable~\cite{WebTable}. 

\cc{Introduce what here? Should avoid repetition with next Section.}

+ Statistics of collected datasets.

+ Clean the datasets.

+ Remove sth.

%Table~\ref{table} summarizes the statistics of collected datasets.


\noindent\textbf{Query Generation}

+ Fake tables: split-based. Split large tables into small ones, which are put into the data lake, and then use some of the small ones as queries.

+ Real tables: retrieved-based. Use real tables as query tables, and directly query the data lake.


+ Classify: 

\quad\quad -- Column type (string, number, category)
 
\quad\quad -- Fake or real
  
\quad\quad -- Selectivity

\quad\quad -- Size

\noindent\textbf{Ground Truth Creation}

+ Semi-automatic label: corresponding to fake tables. Some positive results are automatically generated, while others should be manually labeled.

+ Manually label: corresponding to real tables.

\noindent\textbf{Method Evaluation} \cc{How to category}



    \begin{table*}[t]
        \centering
        \caption{Table Discovery Methods.}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            \centering
            Methods & Task & Index Type & Embedding & KB  \\
            \hline
            \josie~\cite{Josie} & Join & Inverted index & \XSolidBrush & \XSolidBrush  \\
            \hline
            \lsh~\cite{LshEn} & Join & LSH & \XSolidBrush & \XSolidBrush  \\
            \hline
            \pex~\cite{Pexeso} & Join &  Inverted index, Hierarchical gird & \Checkmark & \XSolidBrush  \\
            \hline
            \deepjoin~\cite{DeepJoin} & Join & HNSW & \Checkmark & \XSolidBrush  \\
            \hline
             \tus~\cite{TUS} & Union & LSH & \Checkmark & \Checkmark  \\
            \hline
            \dlll~\cite{D3L} & Union & LSH & \Checkmark & \XSolidBrush  \\
            \hline
            \starmie~\cite{Starmie} & Union & HNSW & \Checkmark & \XSolidBrush  \\
            \hline
            \santos~\cite{Santos} & Union & Inverted index & \XSolidBrush & \Checkmark  \\
            \hline
            \frt~\cite{Frt12} & Join \& Union & \XSolidBrush & \XSolidBrush & \Checkmark  \\
            \hline
            \infogather~\cite{InfoGather} & Join \& Union & Inverted index & \XSolidBrush & \XSolidBrush  \\
            \hline
            \aurum~\cite{Aurum} & Join \& Union & LSH & \Checkmark & \XSolidBrush  \\
            \hline
        \end{tabular}
        \label{table:methods}
        
    \end{table*}

    \begin{table*}[t]
	\centering
	\caption{Complex of Different Table Discovery Methods.}  \vspace{-1em}
	{
		\begin{tabular}{c||cc|cc}
			\toprule
			% 合并单元格
			\multirow{2}{1cm}{\textbf{Methods}} & \multicolumn{2}{c}{\textbf{Offline Process}} & \multicolumn{2}{c}{\textbf{Online Process}} \\ 
			&Time Complexity    & Space Complexity & Time Complexity & Space Complexity \\ 
			\midrule[1pt]     % 中线（或表示为\hline）
			
			\starmie         & O$(\columnnum)$         & O$(\columnnum)$                   & O$(\log \columnnum)$                & O$(\columnnum)$    \\
			\josie             & O$(\cellvaluenum + \rawtokennum \log \rawtokennum)$         & O$(\rawtokennum)$                   & O$(\positinglistlen log \positinglistlen)$         & O$(\positinglistlen)$        \\         
			\lsh          & O$(\columnnum)$        & O$(\columnnum \times \minhashlen)$                   & O$(\querycolumnnum)$                & O$(\querycolumnnum \times \minhashlen)$     \\
			\dlll          & O$(\cellvaluenum + \columnnum)$          & O$(\columnnum)$                   & O$(\querycolumnnum \times \dlllneighbornnum)$                & O($\querycolumnnum$)       \\
			\pex          & O$(\rawtokennum)$        & O$(\rawtokennum)$                   & O$(\querycellvalue + \log \querycellvalue \times \log \rawtokennum)$                & O$(\querycellvalue)$      \\
			\deepjoin         & O$(\columnnum)$         & O$(\columnnum)$                   & O$(\log \columnnum)$                & O$(\columnnum)$     \\
			
			\tus          & O$()$         & O$()$    & O$()$               & O$()$          \\
			\santos              & O$(\rawtokennum)$         & O$(\rawtokennum \times \columnnum {\averagetargetcolumnnum}^2)$    & O$(\querycellvalue + \santosneighbornnum)$               & O$(\querycellvalue)$     \\
			
			\frt-join         &  O$(\columnnum)$        & O$(\columnnum)$    & O$( \tablenum \times {(\querycolumnnum + \averagetargettuplenum)}^3)$               & O$({\averagetargettuplenum}^2)$       \\
			\frt-union         & O$(\tuplenum)$         & O$(\tuplenum)$    & O$(\tablenum \times {(\querycolumnnum + \averagetargettuplenum)}^3)$               & O$({\averagetargettuplenum}^2)$       \\
			\infogather-join        & O$(\columnnum^2)$         & O$(\columnnum^2)$     & O$(\querycolumnnum \times \inforneighbornnum \log \inforneighbornnum)$              & O$(\inforneighbornnum)$      \\
			\infogather-union        & O$(\columnnum^2)$          & O$(\columnnum^2)$    & O$(\querycolumnnum \times \inforneighbornnum \log \inforneighbornnum + {(\querycolumnnum + \averagetargettuplenum)}^3))$              & O$(\inforneighbornnum + {\averagetargettuplenum}^2)$      \\
			\aurum            & O$(\columnnum)$         & O$(\columnnum)$                   & O$(\log \columnnum)$                & O$(\columnnum)$ \\
			SATO            & O$(\columnnum)$         & O$(\columnnum)$                   & O$(\log \columnnum)$                & O$(\columnnum)$    \\
			TABBIE         & O$(\columnnum)$         & O$(\columnnum)$                   & O$(\log \columnnum)$                & O$(\columnnum)$    \\
			TURL         & O$(\columnnum)$         & O$(\columnnum)$                   & O$(\log \columnnum)$                & O$(\columnnum)$    \\
			TURL         & O$(\columnnum)$         & O$(\columnnum)$                   & O$(\log \columnnum)$                & O$(\columnnum)$    \\
			\bottomrule
		\end{tabular}
	}
	\vspace{-1em}
	\label{table:complex_analyse}
	\end{table*}

\begin{table*}[!ht]
	\centering
	\caption{The Meaning of Different Symbols.}
	\begin{tabular}{cc}
		\hline
		Symbol & Meaning \\ \hline
		O & inda \\ 
		$\mathcal{B}$ & Number of columns in the query table$\qtable$  \\
		$\mathcal{N}$ &The total number of columns in all tables in the data lake$\lake$ \\
		$\mathcal{K}$ & The number of non-distinct cell values in all tables in the data lake$\lake$   \\
		$\mathcal{R}$ &The number of distinct cell values in all tables in the data lak$\lake$e \\
		$\mid \mathcal{T} \mid$ & Number of tables in the data lake$\lake$  \\
		$\mathcal{X}$ &The total number of tuples in all tables in the data lake$\lake$ \\
		$\mathcal{A}$ & The number of non-distinct cell values in query table$\qtable$  \\
		
		$\mathcal{L}$ & The length of positing list in \josie  \\
		$\mathcal{H}$ & The dimension of minhash vector \\
		$\mathcal{P}$ & The number of partition in \lsh\\
		$\mathcal{D}$ & The number of neighbors in \dlll\\
		$\mathcal{I}$ & The number of neighbors in \infogather\\
		$\overline{\mathcal{O}}$ & The average number of tuples in target column\\
		%





	
	\end{tabular}
	\label{symbol_table}
\end{table*}

+ \cc{Join/Union}

+ \cc{Schema matching}

+ Hash-based

+ Inverted index 

+ Pre-trained language model (HNSW)


\noindent\textbf{API Design}

