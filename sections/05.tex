%!TEX root = ../main.tex
\section{Query \& ground truth Construction}

\subsection{Synthetic Query Construction}
In this part, we will discuss how to split large tables and generate the corresponding ground truth.

\noindent \textbf{Choosing Large Tables.} 
To split a base table into multiple small synthetic queries, it is usually necessary to use a large base table with more rows and columns. To achieve this, we sorted all the lake tables by multiplying the number of rows and columns of each table. Tables with rows and columns greater than a certain threshold were selected, and in order to ensure the diversity of synthetic queries, we manually selected tables with differenet semantics as the base tables.

\noindent \textbf{Synthetic Query Construction.} 
To generate syhthetic queries that are relatively realistic, including randomness and a certain level of difficulty. We mainly use two methods to generate synthetic queries for join and union case, which involve horizontal and vertical table splitting. 

\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{fig/fake_query.pdf}
	\caption{Overview of Query Construction.}
	\label{fig:query_construction}
\end{figure}


\noindent \underline{\textit{Union Query Construction.}} To generate synthetic queries for the unionable case, it is essential for two small tables to share identical columns. Consequently, we generate unionable scenarios by partitioning the original base table both horizontally and vertically, ensuring there is no overlap in rows and varying the extent of column overlap. As shown in Figure ~\ref{fig:query_construction} - (a),  we first select several columns randomly from base table as column overlap (i.e. column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{2}}}, column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{3}}} and column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{6}}}). Next, we proceed by horizontally splitting the table into multiple parts. Following this, we select the remaining non-duplicate columns as supplementary columns for each part, creating the synthetic queries for the union case.  In the example of the figure, we divide the large table into three parts, for the first part, we choose column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{1}}} and column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{6}}},  add to those overlap columns. In the same way, for the second part, we select column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{4}}} and column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{5}}}, for the last part, we select column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{5}}} and column \raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{7}}}. The tables formed by each part can be unioned with each other.

\noindent \underline{\textit{Join Query Construction.}}  Joinable tables must share one common joinable column, and unlike unionable tables, they should exhibit a substantial row overlap. To construct this case, we first choose a specific column (highlighted in red) as the joinable column (refer to Figure ~\ref{fig:query_construction} - (b)). Subsequently, a random selection of columns (highlighted in yellow) is made to form Table $T_1$, and another set of columns (highlighted in blue) is randomly chosen to create Table $T_2$. The combination of these two tables results in the formation of Table $T$.  For $T_1$ and $T_2$, we represent their rows as $r_{1x}$ and $r_{2x}$ respectively, where $x$ represents the row number. Additionally, we randomly select several columns from  $T$ to create row overlap. Next, we choose a set of rows randomly from both  $T_1$ and  $T_2$, and append them to the overlapping rows. For example, selecting $r_{11}$ from $T_1$ and choose $r_{26}$ as well as $r_{27}$ from $T_2$, allows these two tables to be joined.

\noindent \textbf{Ground Truth Generation.} 
During the process of constructing synthetic queries, ground truth are also generated accordingly.
\noindent \underline{\textit{Union Ground Truth Generation.}}  
As mentioned above, we first divide the base table horizontally into different parts, and then select some small tables with common columns in each part. As a consequence, these small tables are unionable in pairs, so we mark them as ground truth.

\noindent \underline{\textit{Join Ground Truth Generation.}} 
Similarly, when constructing the syhthetic quries for join case, we initially vertically partition the base table into multiple tables, preserving different percentages of overlapping columns (varying from 1 column to 50\% of columns). These overlapping columns and partition tables correspond to the query table and ground truth of the join case respectively.
%+ How to choose large tables.

%+ How to split.

%+ How to generate the ground truth.
\subsection{Basic Search for Candidate Generation}
In this part, for each synthetic or real query, we design a basic search algorithm to retrieve  candidate joinable/unionable tables from the data lake. 

\noindent \underline{\textit{Union Candidate Generation.}}  
To retrieve the unionable tables from the data lake, it not only requires considering $(\romannumeral1 ).$  the semantics of the corresponding columns in two tables (i.e. only considering the semantics between individual column pairs), but also $(\romannumeral2 ).$ the semantics between two tables (i.e. the relationships and semantics between different columns in the same table),  Therefore, we used multiple methods that consider these two semantics separately to obtain results on the query table. Specifically, we use \starmie,\santos and SATO. After that, we take the union of these results as the candidate tables and label them by experts.

\noindent \underline{\textit{Join Candidate Generation.}}  
In the case of joining tables, several considerations are essential:$(\romannumeral1).$ the semantics of corresponding columns in both tables. $(\romannumeral2).$ analyzing the relationship between the two tables, $(\romannumeral3).$ ensuring there is an overlap in cell values between the corresponding columns. Consequently, We used method that considers both $\romannumeral1$ and $\romannumeral2$, namely \deepjoin, and method that considers $\romannumeral3$, namely \josie, to obtain candidate tables respectively.

\noindent  \underline{\textit{Number of Candidate Tables.}}  The number of candidate tables we obtained was determined by experts. We first set an accuracy threshold (i.e. 70\%), and then manually judged that when the number of candidate tables reached a certain number, their corresponding accuracy was lower than the threshold we set. At this point, the number of selected tables is the final number of our candidate tables.
%+ How to guarantee high recall

%+ Details

\subsection{Human Labeling}
In this part, we ask the human experts to label the candidates for each query. In order to improve the efficiency of experts data labeling, we built a webpage for labeling the ground truth of both join and union case.

%+ Example shown to the experts.

\noindent \textbf{Labeling Interface.} 
The labeling interface we built is shown in the Figure ~\ref{fig:interface}, We demonstrate the interface designed for the join case and the interface for the union case follows a similar structure. The interface is primarily divided into three sections , each serving distinct functions. Next, we will elaborate on the functionality of each section.

\noindent \underline{\textit{Query Table Information.}}  
As shown in Figure ~\ref{fig:interface}-\raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{1}}}, this section 
displays the main information of a specific query table, including the metadata associated with it and the progress of the labeling process. The table information  includes its corresponding metadata and the table itself. We can see that for the query table $BuildInfo.csv$, its column names varying from $CSDUID$ to $OriginalValue$. Furthermore, the column $Building Type$ predominantly contains four distinct cell values, such as $Commercial$ and $Industrial$. These meta information are displayed above the query table, serving as supplementary information to assist users in  evaluating whether two tables can be successfully joined or unioned. Beneath the query table, there is a progress bar featuring a green line indicating that 30\% of the query tables have been labeled, and the blue line indicating that 30\% of the query tables are currently undergoing the labeling process.

\noindent \underline{\textit{Set of Candidate Tables.}} This section presents comprehensive details of all candidate tables corresponding to the query table. As shown in Figure ~\ref{fig:interface}-\raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{2}}}, there are three candidate tables, denoted as $Build.csv$, $BuildIntro.csv$ and $SchoolBuild.csv$. Each candidate table is accompanied by a labeling area where users can select two columns from both the query and candidate tables that can be joined, such as $BuildInfo.CSD$ and $Build.CSD$. Given the semantic similarity and overlap between these two columns, they are categorized as joinable types. Upon clicking the "add" button, the interface records and stores this labeled data in the backend database.

\noindent \underline{\textit{Set of Result.}} In this section of the interface, all the annotated data corresponding to the candidate tables is displayed, as illustrated in Figure ~\ref{fig:interface}-\raisebox{.3pt}{\textcircled{\hspace{-0.08cm} \raisebox{-.5pt}{3}}}. For instance, in the case of query table $BuildInfo.csv$ and candidate table $Build.csv$, it is evident that the $Period$ column in the query table only contains year information, whereas the  $Period$ column in the candidate table includes both year and month details, resulting in a lack of overlap between these two columns. Therefore, the labeled information indicates that these two columns cannot be joined (where "no" indicates they cannot be joined, and "yes" indicates they can be joined).
Furthermore, the interface provides a "delete" button to rectify any incorrectly labeled data. Additionally, users can review incomplete data through the page flipping function located below the candidate table, ensuring a thorough evaluation process.




\begin{figure*}[h]
	\centering
	\includegraphics[width=1.0\linewidth]{fig/interface.pdf}
	\caption{Labeling Interface.}
	\label{fig:interface}
\end{figure*}

\noindent \textbf{Labeling Statistics.} 
We have count some statistical information during manual labeling, as show in Table ~\ref{Table:humanLabeling}. For OpenData Large, this dataset has a total of  \cc{XX} query tables to be labeled, with an average of 20 candidate tables matching each query table. Therefore, we have 10 experts and spent a total of approximately \cc{XX} hours completing the labeling work. Similarly, for WebTable Large, we also have 10 experts and spent a total of approximately \cc{XX} hours for labeling. This is because this dataset has \cc{XX} query tables in all that need to be labeled, and each table has an average of 20 corresponding candidate tables.

\begin{table}[t]
	\centering
	\caption{Statistics of Human Labeling.}
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		\centering
		Data Lake  & \#-Query Tables & $\#$-People & Time.   \\
		\hline  
		OpenData Small& 914  & 10 & 10h   \\
		\hline
		OpenData Large& 1,448  & 10  &  17.5h   \\
		\hline
		WebTable Small& 1,745   & 10 &  20h  \\
		\hline
		WebTable Large& 2,245  & 10 &  30h  \\
		\hline
	\end{tabular}
	\label{Table:humanLabeling}
	
\end{table}